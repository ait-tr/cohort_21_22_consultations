import fruits.Orange;
import fruits.Storage;
import fruits.Tree;

public class Main {
    // вопросы
    // - всегда ли нужен массив, если от экземпляра одного класса мы хотим получить экземпляр другого
    public static void main(String[] args) {
        Storage storage = new Storage();
        Tree tree = new Tree();
        while (storage.hasSpace()) { // Безопасно, так как я пытаюсь добавить только после проверки.
            // Цикл закончится, несмотря на то, что массив динамический.
            // Увеличение массива происходит, только если при полном массиве мы вызываем tryAddOrange()
            // а внутрь цикла мы попадаем и вызываем tryAddOrange(), только если осталось место.
            // Значит, если место закончилось, до tryAddOrange() мы не дойдём и увеличения не произойдёт.

            // Автор кода в Main не понял, что boolean tryAddOrange() можно использовать без предварительных проверок,
            // и не знает, что tryAddOrange() увеличит массив.

            // С точки зрения автора класса Storage, метод hasSpace() отвечает только на вопрос, есть ли свободное
            // место в массиве.
            // Его результат никак не связан с вопросом, можно ли добавить новый апельсин.
            // В идеальном мире такой метод должен быть приватным.

            // Автор кода в Main не понял, зачем нужен метод hasSpace() (при динамическом массиве такой публичный метод
            // и правда не нужен), и решил его использовать для проверки.
            // Из-за этого не получилось воспользоваться динамичностью массива в Storage.
            Orange orange = tree.getOrange("друг");
            if (orange != null) { // проверка, правильно ли сработал метод
                if (storage.tryAddOrange(orange)) {
                    System.out.println("Только что добавили апельсин");
                } else {
                    System.out.println("Не получилось добавить апельсин");
                }
            } else {
                System.out.println("Не получилось сорвать апельсин");
                break; // иначе я буду бесконечно пытаться
            }
        }
        storage.look();
    }
}
